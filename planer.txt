Fase 0: A Fundação (Configuração do Projeto)
Antes de escrever a lógica de negócio, preparamos o terreno.

Inicialização do Projeto:

nest new backend

Instalação de dependências-chave: @nestjs/config, @nestjs/passport, @nestjs/jwt, passport-jwt, passport-google-oauth20, prisma, @prisma/client, bcrypt, class-validator, class-transformer, @nestjs/serve-static (para imagens, se for local), nodemailer.

Módulo de Configuração (ConfigModule):

Centralizar o carregamento de variáveis de ambiente (.env).

Definir variáveis: DATABASE_URL, JWT_SECRET, JWT_REFRESH_SECRET, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, EMAIL_HOST, EMAIL_USER, EMAIL_PASS, etc.

Módulo do Prisma (PrismaModule):

Criar um PrismaService que se conecta ao banco e lida com o ciclo de vida da conexão.

Exportar o PrismaService para ser usado por outros módulos.

Definição do Schema (schema.prisma):

Model User: (id, email, name, password, googleId, roles, hashedRefreshToken, etc.)

Model Announcement: (id, title, description, price, rooms, bathrooms, area, type [RENT/SALE], address, etc.)

Model Image: (id, url, announcementId) -> Relação com Announcement.

Model PasswordResetToken: (id, token, userId, expiresAt)

Opcional (para IBGE): State e City (ver Fase 2).

Pipes Globais:

Configurar um ValidationPipe global no main.ts para que todos os DTOs sejam validados automaticamente.

Fase 1: Módulo de Usuário (UserModule)
O recurso central que representa quem usa o sistema.

UserService (Lógica):

create(dto): Criar usuário (usado pelo AuthService no registro). Deve hashear a senha (bcrypt).

findByEmail(email): Encontrar usuário pelo e-mail (usado pelo AuthService no login).

findById(id): Encontrar usuário pelo ID.

update(id, dto): Atualizar dados do perfil (nome, etc.).

delete(id): Deletar a conta do usuário.

updateRefreshToken(userId, token): Salvar o hash do refresh token no usuário.

UserController (Rotas):

GET /users/me: Retorna o perfil do usuário logado (usando um Decorator @User()).

PUT /users/me: Atualiza o perfil do usuário logado.

DELETE /users/me: Deleta a conta do usuário logado.

DTOs (Data Transfer Objects):

CreateUser.dto.ts (com validações: IsEmail, MinLength para senha).

UpdateUser.dto.ts (com validações: IsString, IsOptional).

Segurança: Este controller deve ser inteiramente protegido por um JwtAuthGuard.

Fase 2: Módulo de Localização (LocationModule)
API de utilidade para o frontend (IBGE).

Decisão de Arquitetura:

Opção A (API Externa): O service bate na API do IBGE a cada request. (Simples, mas lento e dependente).

Opção B (Seed no DB): Criar um seed.ts do Prisma com todos os estados e cidades. (Recomendado para performance e confiabilidade).

LocationService:

getStates(): Retorna todos os estados (do seu DB).

getCitiesByState(stateId): Retorna cidades de um estado (do seu DB).

LocationController (Rotas Públicas):

GET /locations/states

GET /locations/states/:stateId/cities

Fase 3: Módulo de Autenticação (AuthModule)
O cérebro da segurança. Lida com login, registro e tokens.

Configuração de Módulos:

Importar UserModule, JwtModule (configurando segredos e tempos de expiração) e PassportModule.

AuthService (Lógica):

register(dto): Chama UserService.create e depois login(user).

validateUser(email, password): Busca usuário por e-mail, compara a senha com bcrypt.compare.

login(user): Gera o accessToken e o refreshToken. Salva o hash do refresh token no usuário.

googleLogin(profile): Lógica "Find-or-Create". Busca usuário pelo googleId ou email. Se não existir, cria um novo. Então, chama login(user).

refreshTokens(userId, refreshToken): Valida o refresh token (comparando com o hash salvo no DB) e gera um novo par de tokens.

AuthController (Rotas Públicas):

POST /auth/register

POST /auth/login (retorna accessToken e refreshToken)

GET /auth/google (Inicia o fluxo OAuth2)

GET /auth/google/callback (Callback do Google, retorna accessToken e refreshToken)

POST /auth/refresh (Recebe refresh token, retorna novo access token)

Strategies (Passport.js):

JwtStrategy: Valida o accessToken (JWT) em rotas protegidas.

GoogleStrategy: Configura o fluxo OAuth2 com o Google.

Guards (Guardas de Rota):

JwtAuthGuard: Protege rotas que exigem um accessToken válido.

GoogleAuthGuard: Usado na rota /auth/google.

Fase 4: Módulo de E-mail e Senha (MailModule & PasswordModule)
Responsável pelo envio de e-mails e fluxo de "esqueci minha senha".

MailModule:

MailService: Um serviço genérico para enviar e-mails (usando Nodemailer). Terá um método sendMail(to, subject, template).

AuthModule (Expansão):

Adicionar ao AuthService:

forgotPassword(email): Gera um token de reset, salva no PasswordResetToken (DB), e chama MailService para enviar o link de reset.

resetPassword(token, newPassword): Valida o token (se existe e não expirou), atualiza a senha do usuário (com hash!), e deleta o token.

Adicionar ao AuthController:

POST /auth/forgot-password

POST /auth/reset-password

Fase 5: Módulo de Anúncios (AnnouncementModule)
O "core business" da aplicação.

AnnouncementService (Lógica):

create(dto, userId): Cria um anúncio associado ao usuário logado.

findAll(filtersDto): A lógica principal. Deve suportar filtros (preço min/max, nº quartos, cidade, etc.) e paginação.

findOne(id): Busca um anúncio.

update(id, dto, userId): Atualiza um anúncio. Deve verificar se o userId é o dono do anúncio.

delete(id, userId): Deleta um anúncio. Deve verificar se o userId é o dono.

AnnouncementController (Rotas):

POST /announcements (Protegido: JwtAuthGuard)

GET /announcements (Público, com Query Params para filtros)

GET /announcements/:id (Público)

PUT /announcements/:id (Protegido: JwtAuthGuard + Guarda de Dono)

DELETE /announcements/:id (Protegido: JwtAuthGuard + Guarda de Dono)

DTOs:

CreateAnnouncement.dto.ts (com muitas validações: IsNumber, IsString, Min, Max, etc.)

UpdateAnnouncement.dto.ts (similar, mas com IsOptional).

QueryAnnouncement.dto.ts (para os filtros da busca).

Autorização (Guards):

IsOwnerGuard (Nome sugerido): Um Guard customizado que verifica se request.user.id === announcement.authorId.

Fase 6: Módulo de Upload (Imagens dos Anúncios)
Nenhum anúncio existe sem fotos.

Decisão de Arquitetura (Storage):

Opção A (Local Storage): Salva arquivos na pasta /uploads e usa o @nestjs/serve-static para servi-los. (Simples para portfólio).

Opção B (Cloud Storage): Salva em um bucket (S3, Google Cloud Storage, Cloudinary). (Mais profissional).

UploadService:

uploadFile(file): Recebe o buffer do arquivo, salva (local ou cloud) e retorna a URL.

Expansão do AnnouncementModule:

Adicionar um UploadController (ou rotas no AnnouncementController) para lidar com multipart/form-data.

POST /announcements/:id/images (Usa FileInterceptor do NestJS para pegar o arquivo).

A lógica salvaria a URL da imagem no Image model, associada ao anúncio.

Fase 7: Módulo de Saúde (HealthModule)
Rotas de teste e verificação.

HealthController:

GET /ping: Rota de teste. Retorna "pong".

GET /health/db: Rota para testar a conexão com o banco. O service tenta fazer um SELECT 1 usando o PrismaService.

Nosso Ponto de Partida
Vamos começar pela Fase 0: A Fundação.

Sua primeira tarefa é:

Criar o projeto NestJS (nest new backend).

Instalar as dependências do npm que listei na Fase 0.

Configurar o PrismaModule e o ConfigModule.

Definir o schema.prisma inicial (apenas com o model User por enquanto).